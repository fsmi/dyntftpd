#!/usr/bin/python
#
# dyntftpd
#
# Copyright (C) 2008 Fabian Knittel <fabian.knittel@fsmi.uni-karlsruhe.de>
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2, or (at your option)
# any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301  USA.

PACKAGE_MODULE_PATH = '.'
CONFIG_FILE = '/etc/dyntftpd.conf'

import sys
sys.path.append(PACKAGE_MODULE_PATH)

from optparse import OptionParser
from ConfigParser import SafeConfigParser
from cStringIO import StringIO
import tftpy
import logging
import logging.config
import os
import socket
import re
import daemon

import file_ver_cmp
import filesys
import boot_label

logger = logging.getLogger('dyntftpd')

def open_newest_file(search_dir, prefix, path, match):
	prefix = prefix + '-'
	suffix = '-' + match.group(1)
	newest_fn = file_ver_cmp.find_highest_file_ver(prefix, suffix, search_dir)
	if newest_fn is not None:
		logger.info("determined newest file: %s" % newest_fn)
		return open(newest_fn, 'rb'), os.stat(newest_fn).st_size
	else:
		return None, 0

def hex_to_ip(hex):
	assert(len(hex) == 8)
	ip_nums = []
	i = 0
	while i < len(hex):
		num = hex[i:i + 2]
		ip_nums.append(str(int(num, 16)))
		i += 2
	return '.'.join(ip_nums)

def gen_pxelinux_cfg(path, match, global_cfg_dir, profile_dirs, domain_regex):
	hex_ip = match.group(1)
	ip = hex_to_ip(hex_ip)
	host = socket.gethostbyaddr(ip)[0]
	domain_match = domain_regex.search(host)
	if domain_match is None:
		return None, 0

	logger.debug('Matched "%s", which is "%s" (%s)' % (path, host, ip))
	profile_dir = os.path.join(profile_dirs, domain_match.group(1))
	profile_file = os.path.join(profile_dir, 'boot_cfg.py')
	if not os.path.exists(profile_file):
		logger.debug('No configuration found for host %s' % host)
		return None, 0

	config_space = {}
	execfile(profile_file, config_space)

	kwargs = {
			'ip': ip,
			'profile_dir': profile_dir,
			'global_cfg_dir': global_cfg_dir
			}
	cfg_data = config_space['create_head_str'](**kwargs)
	for label in config_space['create_labels'](**kwargs):
		cfg_data += str(label)

	return StringIO(cfg_data), len(cfg_data)

def main():
	# Parse command-line options.
	parser = OptionParser()

	parser.add_option("-c", "--config",
					action = "store", dest = "config_file",
					help = "Configuration file",
					default = CONFIG_FILE)

	(options, args) = parser.parse_args()
	if len(args) != 0:
		parser.error("incorrect number of arguments")

	# Load configuration file.
	cf = SafeConfigParser()
	cf.read(options.config_file)

	if cf.has_option('pxe_linux', 'module_path'):
		for path in cf.get('pxe_linux', 'module_path').split(':'):
			sys.path.append(path)


	# Parse configuration file again, this time specifically for logging.
	logging.config.fileConfig(options.config_file)
	logger.info('Loading dyntftpd')

	simul_fs = filesys.SimulatedFileSystem()

	domain_match = re.compile(cf.get('pxe_linux', 'domain_regex'))
	cfg_dir = cf.get('pxe_linux', 'global_cfg_dir')
	profile_dirs = cf.get('pxe_linux', 'profile_cfg_dirs')
	simul_fs.add_handler('^/pxelinux.cfg/([0-9a-fA-F]{8})$',
			lambda p, m: gen_pxelinux_cfg(p, m, cfg_dir, profile_dirs,
					domain_match))

	image_dir = cf.get('overlay', 'image_dir')
	simul_fs.add_handler('^/vmlinuz-([^/]+)$',
			lambda p, m: open_newest_file(image_dir, 'vmlinuz', p, m))
	simul_fs.add_handler('^/initrd.img-([^/]+)$',
			lambda p, m: open_newest_file(image_dir, 'initrd.img', p, m))

	native_fs = tftpy.TftpNativeFileSys(cf.get('tftp', 'root'))

	fss = filesys.FileSystemStack()
	fss.add_file_sys(native_fs)
	fss.add_file_sys(simul_fs)

	server = tftpy.TftpCommonServer(fss)

	if cf.getboolean('tftp', 'background'):
		logger.debug('moving dyntftpd to background')
		daemon.daemonise(pid_file = cf.get('tftp', 'pid_file'))

	try:
		server.listen(cf.get('tftp', 'host'), cf.getint('tftp', 'port'))
	except KeyboardInterrupt:
		pass
	logger.debug('Exiting dyntftpd')

if __name__ == '__main__':
	main()

# vim:set ft=python ts=4:
